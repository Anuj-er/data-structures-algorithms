# Data Structures and Algorithms Practice

This repository contains my collection of DSA problems organized by categories and solution patterns.

## üìÅ Folder Structure

### 01-Arrays-and-Hashing
Problems involving array operations, hash maps, and frequency counting.
- **Key Skills**: Hash table usage, array traversal, mathematical operations
- **Time Complexity**: Usually O(n) or O(n log n)

### 02-Two-Pointers
Problems using two-pointer technique for efficient array/string processing.
- **Key Skills**: Pointer manipulation, sorted array optimization
- **Time Complexity**: Usually O(n)
- **Space Complexity**: Usually O(1)

### 03-Stack-and-Queue
Problems utilizing LIFO (stack) and FIFO (queue) data structures.
- **Key Skills**: Stack/queue operations, expression parsing, monotonic structures
- **Applications**: Parentheses validation, next greater elements, expression evaluation

### 04-String-Manipulation
String processing problems including reversal, merging, and pattern matching.
- **Key Skills**: String operations, character arrays, StringBuilder usage
- **Common Patterns**: Two pointers, character frequency counting

### 05-Sorting-and-Searching
Sorting algorithms and search optimizations.
- **Key Skills**: QuickSort, MergeSort, Binary Search
- **Applications**: Custom sorting, kth element problems

### 06-Sliding-Window
Problems using sliding window technique for subarray/substring problems.
- **Key Skills**: Dynamic window sizing, state tracking
- **Applications**: Maximum/minimum in subarrays, substring problems

### 07-Greedy-Algorithms
Problems solved using greedy approach for optimization.
- **Key Skills**: Local optimization, decision making
- **Applications**: Stock trading, scheduling, pricing optimization

### 08-Linked-List
Linked list manipulation and traversal problems.
- **Key Skills**: Pointer manipulation, list reversal, cycle detection
- **Common Patterns**: Fast and slow pointers, dummy nodes, in-place modifications

### 09-Trees
Binary trees, BST, and tree traversal problems.
- **Key Skills**: Recursion, DFS, BFS, tree construction
- **Applications**: Level-order traversal, path finding, tree validation

### 10-Graphs
Graph traversal and connected component problems.
- **Key Skills**: BFS, DFS, adjacency representations
- **Applications**: Island counting, shortest paths, flood fill

### 11. Backtracking
Combinatorial and constraint satisfaction problems.
- **Key Skills**: Recursive exploration, pruning, state management
- **Applications**: Permutations, combinations, subset generation

### 12. Heap-Priority-Queue
Heap-based problems for priority management.
- **Key Skills**: Min/max heap operations, custom comparators
- **Applications**: Top K problems, median finding, task scheduling

### 13. Math
Mathematical computation and number theory problems.
- **Key Skills**: Number patterns, base conversion, mathematical formulas
- **Applications**: Roman numerals, factorial operations, Fibonacci

### 14. Dynamic Programming
Problems involving optimal substructure and overlapping subproblems.
- **Key Skills**: Memoization, tabulation, space optimization
- **Applications**: Optimization problems, counting paths, sequence alignment

## üéØ Study Strategy

1. **Start with Arrays and Hashing** - Fundamental data structure operations
2. **Move to Two Pointers** - Efficient array processing techniques
3. **Learn Stack and Queue** - Essential for many algorithmic problems
4. **Practice String Manipulation** - Common in coding interviews
5. **Master Sorting and Searching** - Core algorithmic concepts
6. **Intermediate: Sliding Window** - Optimization technique
7. **Intermediate: Greedy Algorithms** - Strategic problem-solving
8. **Data Structures: Linked Lists** - Pointer manipulation mastery
9. **Advanced: Trees** - Hierarchical data structures
10. **Advanced: Graphs** - Complex traversal problems
11. **Expert: Backtracking** - Exhaustive search and pruning
12. **Expert: Heaps** - Priority-based optimizations
13. **Expert: Math** - Numeric and pattern-based logic
14. **Boss Level: Dynamic Programming** - Solving complex problems through subproblems

## ‚úÖ Progress Tracking

- [x] 01-Arrays-and-Hashing (20 problems)
- [x] 02-Two-Pointers (13 problems)
- [x] 03-Stack-and-Queue (14 problems)
- [x] 04-String-Manipulation (8 problems)
- [x] 05-Sorting-and-Searching (4 problems)
- [x] 06-Sliding-Window (7 problems)
- [x] 07-Greedy-Algorithms (4 problems)
- [x] 08-Linked-List (13 problems)
- [x] 09-Trees (45 problems)
- [x] 10-Graphs (19 problems)
- [x] 11-Backtracking (14 problems)
- [x] 12-Heap-Priority-Queue (13 problems)
- [x] 13-Math (9 problems)
- [x] 14-Dynamic-Programming (33 problems)

## üí° Tips

- Understand the pattern before memorizing the solution
- Practice similar problems to reinforce patterns
- Time yourself to improve coding speed
- Review and optimize solutions for better complexity

---
*Happy Coding! üöÄ*
