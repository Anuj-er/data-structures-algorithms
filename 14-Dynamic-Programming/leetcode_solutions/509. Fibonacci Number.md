# ðŸ”¢ 509. Fibonacci Number | 3 Original Approaches

# Intuition
The classic entry point to Dynamic Programming. Every number is the sum of the two preceding ones. This problem is the ultimate demonstration of how to evolve from a slow $O(2^n)$ recursive solution to a lightning-fast $O(1)$ space iterative one.

# Approach
We explore three different ways to calculate the $n^{th}$ Fibonacci number, ranging from memory-light variables to structured recursion.

## ðŸš€ Approach 1: Optimized Iterative (Recommended)
**Why this approach?**  
Maximum speed and minimum memory. By using only three variables (`prev2`, `prev1`, `ans`), we track the sliding window of the sequence without needing an array.

**Use when:** You need the most performant implementation for large $n$.

```java []
class Solution {
    public int fib(int n) {
        if(n<=1) return n;

        int prev2 = 0;
        int prev1 = 1;
        int ans = 0;

        for(int state = 2; state<=n;state++){
            ans = prev1 + prev2; 
            prev2 = prev1;
            prev1 = ans; 
        }
        return ans; 
    }
}
```

---

## ðŸ“ Approach 2: Bottom-Up (Tabulation)
**Why this approach?**  
Uses a full `dp[]` table. This is the "correct" way to learn DP because it explicitly shows the state-building process from the ground up.

**Use when:** You want to record the entire sequence for later use.

```java []
class Solution {
    public int fib(int n) {
        int[] dp = new int[n+1];
        if(n<=1) return n;
        dp[1] = 1;
        for(int state = 2; state<=n;state++){
            dp[state] = dp[state-1] + dp[state-2];
        }
        return dp[n]; 
    }
}
```

---

## ðŸŽ¯ Approach 3: Top-Down (Memoization)
**Why this approach?**  
Perfect for understanding the recursive breakdown. By using `Arrays.fill(dp, -1)`, we ensure subproblems are solved once and only once.

**Benchmark:** Great for interviews to show how you can optimize a "dumb" recursive function.

```java []
class Solution {
    public int fib(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp,-1);
        return recur(n,dp);
    }
    public int recur(int n, int[] dp) {
        if(n<=1){
            dp[n] = n;
            return dp[n];
        }
        if(dp[n]!=-1){
            return dp[n];
        }
        dp[n] = recur(n-1, dp) + recur(n-2, dp); 
        return dp[n];
    }
}
```

---

## ðŸ“Š Performance Comparison

| Approach | Runtime | Memory | Complexity |
|----------|---------|--------|------------|
| **Approach 1** | âš¡ Fastest | ðŸŸ¢ O(1) | O(N) |
| **Approach 2** | âš¡ Fast | ðŸŸ¡ O(N) | O(N) |
| **Approach 3** | ðŸ¢ Slower | ðŸŸ¡ O(N) | O(N) |

**ðŸŽ¯ Key Takeaways:**
- **State Compression**: If a calculation only needs the last `k` values, you only need `k` variables.
- **Base Case**: Always account for $n=0$ and $n=1$ to avoid array index errors.
- **Recursion Depth**: For very large $n$, iterative approaches are safer to avoid `StackOverflowError`.
