# ðŸŽ’ 416. Partition Equal Subset Sum | Recursive & Memoized

# Intuition
Can we split an array into two subsets that sum up to the exact same value? This is a classic "Subset Sum" problem. Since we're looking for two equal halves, our target is simply `totalSum / 2`. If the total sum is odd, we can't possibly split it equally into two integers, so we return false immediately.

# Approach
We use a recursive "Pick vs No-Pick" strategy to find if any subset sums up to the target.

## ðŸŽ¯ Approach: Top-Down Recursion with Memoization
**Why this approach?**  
Clearly models the decision-making process at each element. For every number in the array, we either include it in our subset (and subtract its value from our current target) or skip it. 

**States Tracking:**  
- `index`: Current element being considered.
- `target`: Remaining sum needed to reach `total/2`.
- `dp[index][target]`: Stores `1` if the subproblem is solvable, `0` if not, and `-1` if not yet explored.

```java []
class Solution {                                                                           
    public boolean canPartition(int[] nums) {
        int total = 0;
        for(int num:nums) total += num;
        int n = nums.length;
        int target = total / 2;
        int[][] dp = new int[n][target+1];
        if (total % 2 != 0) return false;

        for(int i=0;i<n;i++){
            Arrays.fill(dp[i],-1);
        }
        return recur(nums,n-1,target,dp) == 1;
    }
    public int recur(int[] nums,int index,int target,int[][] dp){
        if(target == 0) return 1;
        if(index==0){
            return (nums[index] == target)?1:0;
        }
        if(dp[index][target]!= -1) return dp[index][target];

        int pick = 0;
        if(target >= nums[index]){
            pick = recur(nums,index-1,target-nums[index],dp);
        }
        int noPick = recur(nums,index-1,target,dp);
        dp[index][target] = (pick == 1 || noPick == 1)?1:0;
        return dp[index][target];
    }
}
```

---

## ðŸ“Š Complexity Analysis

| Metric | Analysis |
|--------|----------|
| **Time Complexity** | $O(N \cdot \text{Target})$ â€” Each state is calculated once. |
| **Space Complexity** | $O(N \cdot \text{Target})$ â€” Due to the 2D memoization table and recursion stack. |

**ðŸŽ¯ Key Takeaways:**
- **Feasibility Check**: Always verify if the total sum is even before starting the search.
- **Decision Tree**: Using `(pick == 1 || noPick == 1)` is the core of finding if *at least one* path leads to the goal.
- **Optimization Hint**: While recursion is intuitive, this can also be solved iteratively with space optimization to $O(Target)$.
