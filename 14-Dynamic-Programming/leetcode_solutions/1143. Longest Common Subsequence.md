# üßµ 1143. Longest Common Subsequence | 3 Robust Solutions

# Intuition
Find the length of the longest subsequence shared by two strings. If characters match (`text1[i] == text2[j]`), we take that character and look at the remaining strings (`1 + solve(i-1, j-1)`). If they don't, we branch out and find the maximum length by either skipping a character from `text1` or `text2`.

# Approach
We use three variations of Dynamic Programming to solve this: from traditional 2D tables to space-efficient arrays.

## üöÄ Approach 1: Bottom-Up Tabulation (Recommended)
**Why this approach?**  
The most visualized way to solve LCS. It builds a grid where each cell `dp[i][j]` represents the LCS length of prefixes. It also includes a `printLCS` helper to reconstruct the actual string result.

**Use when:** You need to understand the full relationship between the strings or need to reconstruct the actual subsequence.

```java []
class Solution {
    public int longestCommonSubsequence(String t1, String t2) {
        int n = t1.length();
        int m = t2.length();
        int[][] dp = new int[n+1][m+1];
        dp[0][0] = 0;

        for(int i = 1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(t1.charAt(i-1) == t2.charAt(j-1)){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    int case1 = dp[i-1][j];
                    int case2 = dp[i][j-1];
                    dp[i][j] = Math.max(case1,case2);
                }
            }
        }
        printLCS(dp,t1,t2);
        return dp[n][m];
    }

    public void printLCS(int[][] dp, String t1, String t2){
        int i = t1.length();
        int j = t2.length();
        StringBuilder sb = new StringBuilder();

        while(i > 0 && j > 0){
            if(t1.charAt(i-1) == t2.charAt(j-1)){
                sb.append(t1.charAt(i-1));
                i--; j--;
            }
            else if(dp[i-1][j] > dp[i][j-1]){
                i--;
            } else {
                j--;
            }
        }
        System.out.println(sb.reverse().toString());
    }
}
```

---

## üìù Approach 2: Bottom-Up Space Optimized
**Why this approach?**  
Notice that each row in the table only depends on the previous row. By using two arrays (`prev` and `curr`), we cut space complexity from $O(N \cdot M)$ down to $O(M)$.

**Use when:** Memory is tight and you only need the final length, not the reconstruction.

```java []
class Solution {
    public int longestCommonSubsequence(String t1, String t2) {
        int n = t1.length();
        int m = t2.length();
        int[] prev = new int[m+1];
        prev[0] = 0;

        for(int i = 1;i<=n;i++){
            int[] curr = new int[m+1];
            for(int j=1;j<=m;j++){
                if(t1.charAt(i-1) == t2.charAt(j-1)){
                    curr[j] = 1 + prev[j-1];
                }else{
                    int case1 = prev[j];
                    int case2 = curr[j-1];
                    curr[j] = Math.max(case1,case2);
                }
            }
            prev = curr;
        }
        return prev[m];
    }
}
```

---

## üéØ Approach 3: Top-Down (Memoization)
**Why this approach?**  
Directly maps the recursive formula. Useful for understanding the subproblem logic without worrying about the iteration order.

**Use when:** You want a clean, recursive solution.

```java []
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length();
        int m = text2.length();
        int[][] dp = new int[n+1][m+1];
        for(int i = 0;i<=n;i++){
            Arrays.fill(dp[i],-1);
        }
        return recur(n,m,text1,text2,dp);
    }
    public int recur(int i, int j,String t1, String t2,int[][] dp){
        if(i==0 || j==0){
            dp[i][j] = 0;
            return 0;
        }
        if(dp[i][j] != -1) return dp[i][j];
        if(t1.charAt(i-1) == t2.charAt(j-1)){
            dp[i][j] = 1 + recur(i-1,j-1,t1,t2,dp);
            return dp[i][j];
        }else{
            int case1 = recur(i-1,j,t1,t2,dp);
            int case2 = recur(i,j-1,t1,t2,dp);
            dp[i][j] = Math.max(case1,case2);
            return dp[i][j];
        }
    }
}
```

---

## üìä Performance Comparison

| Approach | Space | Time | Best For |
|----------|-------|------|----------|
| **Tabulation** | üî¥ $O(N \cdot M)$ | $O(N \cdot M)$ | Reconstructing the string |
| **Optimized** | üü¢ $O(M)$ | $O(N \cdot M)$ | Competitive programming (Memory) |
| **Memoization** | üî¥ $O(N \cdot M)$ | $O(N \cdot M)$ | Understanding logic |

**üéØ Key Takeaways:**
- **Diagonal Move**: A match always results in a diagonal step back in the table.
- **Max Move**: A mismatch looks at the best result from either neighbor (left or up).
- **Infinite Combinations**: LCS is the parent problem for many others like Edit Distance and Shortest Common Supersequence.
