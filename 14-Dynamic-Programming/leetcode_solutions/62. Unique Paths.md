# ğŸ 62. Unique Paths | 3 Optimized Approaches

# Intuition
A robot starts at the top-left of a grid and needs to get to the bottom-right. It can only move Right or Down. To reach any cell `(i, j)`, it must have come from either the cell above it `(i-1, j)` or the cell to its left `(i, j-1)`. 

# Approach
The total unique paths is simply the sum of paths from these two neighbors.

## ğŸš€ Approach 1: Space Optimized Bottom-Up (Recommended)
**Why this approach?**  
Maximum memory efficiency. We only need two rows (`prev` and `curr`) to compute the final count. Instead of an $M \times N$ grid, we use just $O(N)$ space.

**Use when:** Memory is a priority and the grid is very large.

```java []
class Solution {
    public int uniquePaths(int m, int n) {
        int[] prev = new int[n];

        for(int j = 0; j<n ;j++) prev[j] = 1;

        for(int i = 1; i<m;i++){
            int[] curr = new int[n];
            curr[0] = 1;
            for(int j=1;j<n;j++){
                curr[j] = prev[j] + curr[j-1];
            }
            prev = curr;
        }
        return prev[n-1];
    }
}
```

---

## ğŸ“ Approach 2: Tabulation (Grid-Based)
**Why this approach?**  
Clearly demonstrates the 2D nature of the problem. We fill the first row and first column with `1` (because there's only one way to go straight) and then fill the rest.

**Use when:** You want the most intuitive, grid-based visualization of the algorithm.

```java []
class Solution {
    int[][] dp;
    public int uniquePaths(int m, int n) {
        dp = new int[m][n];

        for(int i = 0; i<m ;i++) dp[i][0] = 1;
        for(int j = 0; j<n ;j++) dp[0][j] = 1;

        for(int i = 1; i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

---

## ğŸ¯ Approach 3: Top-Down (Memoization)
**Why this approach?**  
Matches the recursive logic: `Paths(i, j) = Paths(i+1, j) + Paths(i, j+1)`. We cache results in a 2D array to avoid re-exploring the same cell multiple times.

**Use when:** You prefer a recursive style and want to see the path exploration from the source.

```java []
class Solution {
    int[][] dp;
    public int uniquePaths(int m, int n) {
        dp = new int[m][n];
        return recur(0,0,m,n);
    }
    public int recur(int x, int y, int m,int n){
        if(x == m-1 && y == n-1){
            return 1;
        }

        if(x >= m || y >= n) return 0;

        if(dp[x][y] != 0) return dp[x][y];

        int right = recur(x,y+1,m,n);
        int down = recur(x+1,y,m,n);

        dp[x][y] = right+down;
        return dp[x][y];
    }
}
```

---

## ğŸ“Š Performance Comparison

| Approach | Space | Readability | Logic Flow |
|----------|-------|-------------|------------|
| **Optimized** | ğŸŸ¢ O(N) | â­â­â­â­ | Incremental |
| **Tabulation**| ğŸ”´ O(M*N) | â­â­â­â­â­ | Sequential |
| **Memoization**| ğŸ”´ O(M*N) | â­â­â­â­ | Recursive |

**ğŸ¯ Key Takeaways:**
- **Boundary Conditions**: Every cell in the first row and column has exactly 1 path leading to it.
- **Summation Pattern**: The core formula `dp[i][j] = dp[i-1][j] + dp[i][j-1]` is a simplified version of Pascal's Identity.
- **Combinatorics**: You can actually solve this in $O(1)$ space and $O(M)$ time using the Binomial Coefficient formula: $\binom{m+n-2}{m-1}$.
