# ðŸ§— 70. Climbing Stairs | 3 Solutions (Bottom-Up + Top-Down)

# Intuition
Reach `n` from `n-1` (1 step jump) or `n-2` (2 step jump). It's essentially the Fibonacci sequence. Imagine you're at the base of a staircase â€” every step you take is either a small hop or a bigger leap. The total ways to reach the top is just the sum of ways to reach the two steps below it.

# Approach
We solve this by breaking down the number of ways to reach each step into smaller subproblems. 

## ðŸš€ Approach 1: Bottom-Up Optimized (Recommended)
**Why this approach?**  
Maximum performance using only two variables to track previous states. Since we only need the last two steps to find the current one, we don't need a whole array. This is the most memory-efficient way to solve the problem.

**Use when:** You want the fastest solution with minimum memory footprint.

**Benchmark advantage:** Constant space $O(1)$ compared to $O(n)$ for array-based approaches.

```java []
class Solution {
    public int climbStairs(int n) {
        if(n<=2) return n;
        int prev2 = 1;
        int prev1 = 2;
        int ans = 0;
        for(int state = 2;state<n;state++){
            ans = prev1 + prev2;
            prev2 = prev1;
            prev1 = ans;
        }
        return ans;
    }
} 
```

---

## ðŸ“ Approach 2: Bottom-Up (Tabulation)
**Why this approach?**  
Uses a full DP array to visualize the process step-by-step. It's often easier to debug because you can see the state of every single stair.

**Use when:** You need to record the number of ways for all stairs or if the problem requires more complex state history.

```java []
class Solution {
    public int climbStairs(int n) {
        if(n<=2) return n;
        int[] dp = new int[n];
        dp[0] = 1;
        dp[1] = 2;
        for(int state = 2;state<n;state++){
            dp[state] = dp[state-1] + dp[state-2];
        }
        return dp[n-1];
    }
} 
```

---

## ðŸŽ¯ Approach 3: Top-Down (Memoization)
**Why this approach?**  
Matches the natural recursive intuition. We store results in a `dp` table to avoid repeating expensive calculations.

**Use when:** You want a clean, recursive logic that clearly shows the subproblem relationship.

```java []
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp,-1);
        return recur(n,dp);
    }
    public int recur(int n,int[] dp){
        if(n<=2){
            dp[n] = n;
            return n;
        }
        if(dp[n]!=-1) return dp[n];
        dp[n] = recur(n-1,dp) + recur(n-2,dp);
        return dp[n];
    }
} 
```

---

## ðŸ“Š Performance Comparison

| Approach | Runtime | Memory | Readability |
|----------|---------|--------|-------------|
| **Approach 1** (Optimized) | âš¡ Fastest | ðŸŸ¢ O(1) | â­â­â­â­â­ |
| **Approach 2** (Tabulation) | âš¡ Fast | ðŸŸ¡ O(N) | â­â­â­â­ |
| **Approach 3** (Memoization) | ðŸ¢ Slower | ðŸ”´ O(N) | â­â­â­â­ |

**ðŸŽ¯ Key Takeaways:**
- **Recurrence Relation**: `f(n) = f(n-1) + f(n-2)`
- **Base Cases**: Handle `n=1` and `n=2` explicitly to avoid overflow or logic errors.
- **Space-Time Tradeoff**: All approaches are $O(n)$ time, but variable-swapping saves significant memory.
