# ðŸª™ 518. Coin Change II | Optimized Combinations

# Intuition
Find the total number of ways to make up a specific `amount` using a set of coins. This is the **Counting version** of the coin change problem. Instead of finding the *minimum* coins, we sum up every possible combination. Because of the infinite supply, it's another unbounded knapsack variation.

# Approach
We use space-optimized DP to accumulate the total count of ways.

## ðŸš€ Optimized Bottom-Up Approach
**Why this approach?**  
Uses only two rows (`prev` and `curr`) to track combinations. This is memory-efficient and avoids the overhead of a full 2D matrix. 

**Logic:**  
- **Pick**: Ways to make `(a - current_coin)` using the same coin again.
- **No-Pick**: Ways to make `a` using only previous coin types.
- **Sum**: `Total = Pick + No-Pick`.

```java []
class Solution {

    public int change(int amount, int[] coins) {
        int n = coins.length;
        int[] prev = new int[amount+1];
        for(int a=0;a<=amount;a++){
            if(a % coins[0] == 0)
                prev[a] =  1;
            else
                prev[a] = 0;
        }
        
        for(int i=1;i<n;i++){
            int[] curr = new int[amount+1];
            for(int a=0;a<=amount;a++){
               int pick = 0;
                if(a >= coins[i])
                    pick = curr[a-coins[i]];
                int noPick = prev[a];
                curr[a] = pick+noPick; 
            }
            prev = curr;
        }
        return prev[amount];
    }
}
```

---

## ðŸ“Š Comparison: Coin Change I vs II

| Problem | Goal | Formula |
|---------|------|---------|
| **Coin Change I** | Minimum count | `min(pick, noPick)` |
| **Coin Change II** | Total ways | `pick + noPick` |

**ðŸŽ¯ Key Takeaways:**
- **Combinations vs Permutations**: By iterating coin-by-coin (outer loop), we ensure we only count unique sets of coins, not their different orderings.
- **Base Case**: One way to make sum 0 (by using no coins). For the first coin, if it divides the amount exactly, there's exactly 1 way to form it.
- **Space Efficiency**: $O(A)$ space is achievable by using a single array, but the two-row version clearly shows the "Pick vs No-Pick" dependency.
