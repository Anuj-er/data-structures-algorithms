# ðŸ—ï¸ 1092. Shortest Common Supersequence | Original LCS-Based Reconstruction

# Intuition
A supersequence is a string that contains both `str1` and `str2` as subsequences. To make it the **shortest**, we should reuse as many characters as possible. The characters we can reuse are exactly those in the **Longest Common Subsequence (LCS)**. Every other character from both strings must be added into the final result in their original relative order.

# Approach
We solve this by first building the LCS table and then backtracking through it to construct the supersequence.

## ðŸš€ LCS Backtracking Approach
**Why this approach?**  
This is the most mathematically sound way to ensure the result is the absolute shortest. By using a helper method `longestCommonSubsequence` to build the full 2D DP table, we get a clear map of where the two strings overlap.

**Reconstruction Logic:**
1. **Match**: If `str1[i] == str2[j]`, append character once and move diagonally.
2. **Mismatch**: Append the character from the string that *doesn't* contribute to the current LCS cell's value and move left or up.
3. **Finish**: If one string is exhausted, append the remainder of the other string.
4. **Reverse**: Since we built from the end, reverse the `StringBuilder`.

```java []
class Solution {

    public String shortestCommonSupersequence(String str1, String str2) {
        int[][] dp = longestCommonSubsequence(str1,str2);
        int n = dp.length;
        int m = dp[0].length;
        int i = n-1;
        int j = m-1;
        StringBuilder sb = new StringBuilder();
        while(i>0 && j>0){
            if(str1.charAt(i-1) == str2.charAt(j-1)){
                sb.append(str1.charAt(i-1));
                i--;
                j--;
            }else if(dp[i-1][j]>dp[i][j-1]){
                sb.append(str1.charAt(i-1));
                i--;
            }else{
                sb.append(str2.charAt(j-1));
                j--;
            }
        }
        while(i>0){
            sb.append(str1.charAt(i-1));
            i--;
        }
        while(j>0){
            sb.append(str2.charAt(j-1));
            j--;
        }
        return sb.reverse().toString();
    }
    public int[][] longestCommonSubsequence(String str1, String str2){
        int n = str1.length();
        int m = str2.length();
        int[][] dp = new int[n+1][m+1];

        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                if(str1.charAt(i-1) == str2.charAt(j-1)){
                    dp[i][j] = 1 + dp[i-1][j-1];
                }else{
                    int case1 = dp[i][j-1];
                    int case2 = dp[i-1][j];
                    dp[i][j] = Math.max(case1,case2);
                }
            }
        }
        return dp;
    }
}
```

---

## ðŸ“Š Complexity Analysis

| Metric | Analysis |
|--------|----------|
| **Time Complexity** | $O(N \cdot M)$ â€” To build the LCS table and backtrack. |
| **Space Complexity** | $O(N \cdot M)$ â€” To store the DP table. |

**ðŸŽ¯ Key Takeaways:**
- **Inclusion**: Every character of `str1` and `str2` must appear in the result.
- **Backtracking**: The `while(i>0 && j>0)` loop with `if/else if/else` is the standard pattern for string reconstruction from a 2D DP table.
- **Shortest Length**: The length of the result will always be `len(str1) + len(str2) - len(LCS)`.
