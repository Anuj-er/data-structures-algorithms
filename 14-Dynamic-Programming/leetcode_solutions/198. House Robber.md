# üè† 198. House Robber | 3 Solutions (Bottom-Up + Top-Down)

# Intuition
You're a pro robber planning to rob houses along a street. Each house has some money, but there's a catch: you can't rob two adjacent houses. At every house `i`, you have a simple choice: **Rob it** (and add it to loot from 2 houses back) or **Skip it** (and carry over the loot from the previous house).

# Approach
This is a dynamic programming problem where the current maximum depends on the decisions made at preceding houses.

## üöÄ Approach 1: Space Optimized (Recommended)
**Why this approach?**  
Maximum performance using two variables to keep track of the max loot from the last two houses. It eliminates the need for a full array, making it perfect for long streets.

**Use when:** You want optimal performance and constant space usage.

```java []
class Solution {
    public int rob(int[] nums) {
        int size = nums.length;
        if(size == 0) return 0;
        if(size == 1) return nums[0];
        int prev2 = 0;
        int prev1 = nums[0];

        for(int i = 2;i<=size;i++){
            int pick = nums[i-1] + prev2;
            int noPick = prev1;
            int ans = Math.max(pick,noPick);
            prev2 = prev1;
            prev1 = ans;
        }
        return prev1;
    }
}
```

---

## üìù Approach 2: Bottom-Up (Tabulation)
**Why this approach?**  
Uses a full `dp` array where `dp[i]` stores the maximum money that can be robbed up to the $i^{th}$ house. It's very structured and mirrors the mathematical recurrence perfectly.

**Use when:** You need to visualize the maximum loot collected at every single point.

```java []
class Solution {
    public int rob(int[] nums) {
        int size = nums.length;
        if(size == 0) return 0;
        if(size == 1) return nums[0];
        int[] dp = new int[size+1];
        dp[0] = 0;
        dp[1] = nums[0];
        for(int i = 2;i<=size;i++){
            int pick = nums[i-1] + dp[i-2];
            int noPick = dp[i-1];
            dp[i] = Math.max(pick,noPick);
        }
        return dp[size];
    }
}
```

---

## üéØ Approach 3: Top-Down (Memoization)
**Why this approach?**  
Directly translates the recursive choice: `max(nums[n] + recur(n-2), recur(n-1))`. Storing results in `dp[]` ensures we solve each subproblem only once.

**Use when:** You prefer recursion and want to explicitly model the decision tree.

```java []
class Solution {
    public int rob(int[] nums) {
        int size = nums.length;
        if(size == 0) return 0;
        int[] dp = new int[size];
        Arrays.fill(dp,-1);
        recur(size-1,nums,dp);
        return dp[size-1];
    }
    public int recur(int n,int[] nums,int[] dp){
        if(n<0){
            return 0;
        }
        if(dp[n] != -1) return dp[n];
        int pick = nums[n] + recur(n-2,nums,dp);
        int noPick = 0 + recur(n-1,nums,dp);
        dp[n] = Math.max(pick,noPick);
        return dp[n];
    }
}
```

---

## üìä Performance Comparison

| Approach | Runtime | Memory | Complexity |
|----------|---------|--------|------------|
| **Approach 1** | ‚ö° Fastest | üü¢ O(1) | O(N) |
| **Approach 2** | ‚ö° Fast | üü° O(N) | O(N) |
| **Approach 3** | üê¢ Slower | üî¥ O(N) | O(N) |

**üéØ Key Takeaways:**
- **Core Choice**: `dp[i] = max(nums[i] + dp[i-2], dp[i-1])`
- **Zero House Case**: Always handle empty input and single-house cases first.
- **State Compression**: If the current state only depends on a constant number of previous states, space can be reduced to $O(1)$.
- **Gadha Logic**: For beginners, you might think alternating houses works (rob 0, 2, 4 vs 1, 3, 5), but that fails for cases like `[2, 1, 1, 2]`. DP is essential!
