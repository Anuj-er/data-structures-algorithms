# üèòÔ∏è 213. House Robber II | Circular Optimization

# Intuition
The houses are in a circle! This means the first house and the last house are neighbors. If you rob the first one, you can't rob the last. This breaks the standard linear logic. The clever fix? **Solve the linear problem twice**: once ignoring the first house, and once ignoring the last.

# Approach
We split the array into two subarrays and run the standard "House Robber I" logic on both.

## üöÄ Linear Reduction Approach
**Why this approach?**  
Uses a helper method `rob1` to handle the linear case. By splitting the problem into two scenarios (Exclude First vs. Exclude Last), we effectively "cut" the circle into two linear streets.

**Steps:**
1. **Scenario 1**: Skip index 0, rob houses `1` to `n-1`.
2. **Scenario 2**: Skip index `n-1`, rob houses `0` to `n-2`.
3. **Compare**: The answer is `max(Scenario 1, Scenario 2)`.

```java []
class Solution {
    public int rob1(int[] nums) {
        int size = nums.length;
        if(size == 0) return 0;
        if(size == 1) return nums[0];
        int prev2 = 0;
        int prev1 = nums[0];

        for(int i = 2;i<=size;i++){
            int pick = nums[i-1] + prev2;
            int noPick = prev1;
            int ans = Math.max(pick,noPick);
            prev2 = prev1;
            prev1 = ans;
        }
        return prev1;
    }
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 0) return 0;
        if(n == 1) return nums[0];
        int[] num1 = new int[n-1];
        int[] num2 = new int[n-1];
        int j = 0, k = 0;
        for(int i = 0;i<n;i++){
            if(i != 0){
                num1[j++] = nums[i];
            }
            if(i != n-1){
                num2[k++] = nums[i];
            }
        }
        return Math.max(rob1(num1),rob1(num2));
    }
}
```

---

## üìä Performance Comparison

| Metric | Linear Robber | Circular Robber |
|--------|---------------|-----------------|
| **Time** | O(N) | O(N) |
| **Space** | O(1) | O(N) (due to array copying) |

**üéØ Key Takeaways:**
- **Circular Dependency**: Any circular problem can usually be broken into two linear subproblems by fixing an edge case.
- **Edge cases**: If `n=1`, just rob that house. The split logic only works for `n > 1`.
- **Space Tip**: You can avoid the subarray copies by passing `start` and `end` indices to a modified `rob1` method to reach $O(1)$ space.
